%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% File    : test_es.m                                                     %
%                                                                         %
% Author  : Tobias Holicki                                                %
% Date    : 18.04.2023                                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This script compares two non-impulsive estimator design approaches for 
% discrete-time impulsive systems. One of these approaches relies on a 
% variation of the IQC theorem from [1] where we view the impulse as 
% generated by an uncertain operator and where we constructed an IQC for 
% this operator based on the lifting approach.
% The other approach is essentially a discrete-time version of a result 
% from [2] which is based on the clock based approach from [3] and employs
% slack variables [4].
%
% [1] C. W. Scherer, J. Veenman, Stability analysis by dynamic dissipation
%     inequalities: On merging frequency-domain techniques with time domain
%     conditions, 2018
% [2] T. Holicki, A complete analysis and design framework for linear 
%     impulsive and related hybrid systems, 2022
% [3] C. Briat, Convex conditions for robust stability analysis and 
%     stabilization of linear aperiodic impulsive and sampled-data systems 
%     under dwell-time constraints, 2013
% [4] J. C. Geromel, M. C. de Oliveira, J. Bernussou, Robust filtering for
%     discrete-time linear systems with parameter dependent Lyapunof
%     functions, 2002

% Clean up
clc
clear

% Addpath for auxiliary functions
addpath(genpath('AuxiliaryFunctions'));


%% Problem data

% Data of to-be-estimated system
Ts = 0.05; % Sampling time (essentially only for simulations)
A  = [0.18, 0.34; -0.58, 1.08];
B  = [-0.02; -0.01];
C  = [0, 1; 1, 0];
D  = [0; 0];
AJ = [0.47, 0.41; -0.01, -0.02];
BJ = [0; 1.32];
CJ = [0, 1; 0, 0];
DJ = [0; 0];

% Signal dimensions
lx = size(A, 1); % state
ld = size(B, 2); % generalized disturbance
le = 1;          % estimation error
ly = 1;          % measured output

% Open-loop in terms of a standard impulsive system with flow and jump 
% component
sysF = ss( A, [ B, zeros(lx, ld)],  C, [ D, -eye(le, le+ly)'], Ts);
sysJ = ss(AJ, [BJ, zeros(lx, ld)], CJ, [DJ, -eye(le, le+ly)'], Ts);
% Corresponding input and output partition
inpI = [ld, le];
outI = [le, ly];


% Open-loop in terms of a feedback interconnection with an impulsive 
% operator and the following linear part
sys = ss(A, [AJ - A, BJ - B, B, zeros(lx, le)], ...
         [eye(lx, lx+ld)'; C], ...
         [zeros(lx+ld), [zeros(lx, ld); eye(ld)], zeros(lx+ld, le); ...
          CJ - C, DJ - D, D, -eye(le, le+ly)'], Ts);
% Corresponding input and output partition
inp = [lx+ld, ld, le];
out = [lx+ld, le, ly];

% Considered dwell-time
T = [9,10];

%% Construct some estimators

% Design by ignoring the impulsive nature of the system
[Enom, ~, ga] = hinfsyn(sysF, 1, 1);
disp(['Energy gain by ignoring the impulsive part : ', num2str(ga)])

% Design by combining clock and slack variable approach. Note that for 
% estimation problems some blocks of the slack variables are allowed to 
% depend on the clock.
[ga, Esvar] = design_es_svar(sysF, sysJ, inpI, outI, T);
disp(['Upper bound by clock and slack variable approach : ', num2str(ga)])

% IQC based design where the impulsive operator is captured by lifting
% techniques and the following filter:
psi = basis_filter(1, 2*out(1), pole=0, type=2, sampling_time = Ts); 
[ga, Eiqc] = design_es_iqc(sys, inp, out, T, psi=psi);
disp(['Upper bound by IQC and lifting approach : ', num2str(ga)])


%% Simulation 1
      
rng default;              % For reproducibility
dt = randi(T, 12, 1);     % Generate random dwell-times
t  = cumsum([-1; dt+1]);  % Sequence of impulse instants
E  = {Eiqc, Esvar, Enom}; % Cell of synthesized estimators
ee = cell(2, 1);          % Cell for estimation errors

% Several simulations
for k = 1 : length(E)
    % Build closed-loop
    cl = lft(sys, E{k});
    for j = 1 : 2
        x = zeros(size(cl.a, 2), 1);  % Zero initial condition
        d = @(i) fun(i, j);           % Generalized disturbance
        e = zeros(le, t(end));        % Estimation error
        % Simulate response
        for i = 1 : t(end)
            % Currently active system
            if ~ismember(i, t) % Then the flow component is active
                sya     = lft(zeros(inp(1)), cl);   
            else % Then the jump component is active 
                sya     = lft(eye(inp(1)), cl);
            end
            e(:, i) = sya.c * x + sya.d * d(i); % Update perf. output
            x       = sya.a * x + sya.b * d(i); % Update state
        end
        ee{j}(k, :) = e;
    end
end

% Plot results
figure
subplot(3, 1, 1:2)
box on; grid on;
semilogy(1:t(end), abs(ee{2}), 'linewidth', 1.5)
%legend('Thm 3.3', 'Thm 3.4', 'hinfsyn')
xlabel('time')
ylabel('Estimation error |v-u|')
ylim([1e-3, 1e1])
xlim([0, 120])



%% Simulation 2

% A modification of the open-loop system whose error signal is the stacked
% estimate and the to-be-estimated output. This is only for plotting the 
% latter two signals conveniently.
sysm = ss(A, [AJ - A, BJ - B, B, zeros(lx, le)], ...
         [eye(lx, lx+ld)'; zeros(le, lx); C], ...
         [zeros(lx+ld), [zeros(lx, ld); eye(ld)], zeros(lx+ld, le); ...
          zeros(le, lx+2*ld), eye(le); ...
          CJ - C, DJ - D, D, zeros(le+ly, le)], Ts);
      
Et = {'Thm 3.3', 'Thm 3.4', 'hinfsyn'}; % This is for the legends

% Several simulations
for k = [1, 3]
    % Build closed-loop
    cl = lft(sysm, E{k});

    for j = 1 : 2
        x = zeros(size(cl.a, 2), 1);  % Zero initial condition
        d = @(i) fun(i, j);           % Generalized disturbance
        e = zeros(2*le, t(end));      % Output and estimate
        % Simulate response
        for i = 1 : t(end)
            if ~ismember(i, t) % Then the flow component is active
                sya     = lft(zeros(inp(1)), cl);   % Current system
                e(:, i) = sya.c * x + sya.d * d(i); % Update perf. output
                x       = sya.a * x + sya.b * d(i); % Update state
            else % Then the jump component is active 
                sya     = lft(eye(inp(1)), cl);     % Current system
                e(:, i) = sya.c * x + sya.d * d(i); % Update perf. output
                x       = sya.a * x + sya.b * d(i); % Update state
            end
        end

        % Plot results
        figure
        subplot(3, 1, 1:2)
        box on; grid on;
        plot(1:119, e(2:-1:1, 1:119), '*')
        legend('System output v', ['Estimate u by ', Et{k}])
        xlabel('time')
        xlim([0, 120])
    end
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Function : fun                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% Some functions playing the roles of generalized disturbances.
function d = fun(t, j)
    if j == 1 % First function
        if t < 60
            d = 4;
        else 
            d = -2;
        end
    else % Second function
        if t < 60
            d = -2*cos(0.5*t);
        else 
            d = 3*sin(0.25*t);
        end
    end
end
